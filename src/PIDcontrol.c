/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stm32f051x8.h>
#include <pwmInit.h>
#include <adcInit.h>
#include <readAdc.h>
#include <initIR.h>
#include <stdint.h>
#include "stm32f051x8.h"

int t = 0;
int flag = 0;
int analogRead3 = 0;


	// Variables del controlador
	float m = 0;
	float error = 0, error_1 = 0;
	float int_error = 0, der_error = 0;
	float x_masa = 0, x_ref = 0;

	// Ganancias del Controlador
	float Kp = 0.28, Ki = 10.0, Kd = 0.05;


	int main(void){
		pwmInit();
		adcInit();
		initIR();
		while(1){


		// Algoritmo de control se ejecuta cada 1 milisegundo (Frec. timer TIM14 = 1MHz, ARR = 1000)
		if(flag==1){
			flag = 0; // Regresamos bandera a cero
			if(t<4000){//FunciÃ³n step
				x_ref = 0.5;
			}
			else if(t<8000){
				x_ref = 1.5;

			}else{
				t = 0;
			}
			// Declarar el valor donde queremos que este la masa (referencia)
			//x_ref = 2;

			// Lectura de la posicion de la masa
			analogRead3=readAdc();
			x_masa = 3.3*analogRead3/4095;

			// Algoritmo de control
			error = x_ref - x_masa;  // Posicion de referencia menos la posicion obtenida
			int_error = int_error + 0.001 * error;  // Integral del error (Por aproximacion)
			der_error = (error - error_1) / 0.001;

			error_1 = error; //actualizar el valor del error un instante anterior

			// Ecuacion del PID
			m = Kp * error + Ki * int_error + Kd * der_error;

			if(m>3.3){ // Saturamos la variable y para que no sea menor a 0 volts, ni mayor a 3.3 volts
				m=3.3;
			}
			else if(m<0){
				m=0;
		}
			TIM3->CCR4 = m*500/3.3; // Escalamos la variable y: (0 - 3.3V) -> (0 - 500 Duty Cycle) TIM3 ARR = 500
			//DAC->DHR12R1 = m*4095/3.3;
		}
	}
}
void TIM14_IRQHandler(void){
	TIM14->SR = 0; // Clear status register
	flag = 1;
	t = t + 1; // tiempo en milisegundos
}

