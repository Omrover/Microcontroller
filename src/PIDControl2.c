/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stm32f051x8.h>
#include <pwmInit.h>
#include <adcInit.h>
#include <readAdc.h>
#include <initIR.h>


#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

int t = 0;
int flag = 0;
int analogRead3 = 0;

float x_refVel=0; //Referencia
float x_vel=0; //Posición real
float m=0; // Amplificación proporcional de error
float e=0; // Error (diferencia)
float e_1=0; // Error (diferencia acumulada)
float kp=0.8; //Proporcional
float ki=5; //Proporcional
float kd=0.00001; //Proporcional
float int_error=0; //Integral
float der_error=0; //Derivativo
int encoder_counter =0;
static float encoder_prev = 0;  // variable estática para guardar lectura anterior
float delta;

//Coeficientes con tiempo de simulación t=1ms
float a = 7.18266490806209e-05;
float b = 7.16544710587613e-05;
float c = -1.99268237678367;
float d = 0.992825857903813;
void encoderInit(void);
int encoder_get_count(void);

void encoderInit(void) {
    /* 1. Habilitar relojes */
    RCC->AHBENR  |= RCC_AHBENR_GPIOAEN;   // Habilitar GPIOA
    RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;   // Habilitar TIM2

    /* 2. Configurar PA0 y PA1 como Alternate Function AF2 */
    // PA0 -> TIM2_CH1
    GPIOA->MODER &= ~(3U << (0 * 2));
    GPIOA->MODER |=  (2U << (0 * 2));        // Alternate function
    GPIOA->AFR[0] &= ~(0xF << (0 * 4));
    GPIOA->AFR[0] |=  (2U << (0 * 4));       // AF2 = TIM2_CH1

    // PA1 -> TIM2_CH2
    GPIOA->MODER &= ~(3U << (1 * 2));
    GPIOA->MODER |=  (2U << (1 * 2));        // Alternate function
    GPIOA->AFR[0] &= ~(0xF << (1 * 4));
    GPIOA->AFR[0] |=  (2U << (1 * 4));       // AF2 = TIM2_CH2

    /* 3. Configurar TIM2 en modo encoder */
    TIM2->CR1   = 0x0000;  // Reset control register
    TIM2->SMCR  = 0x0000;  // Reset SMCR
    TIM2->CCMR1 = 0x0000;  // Reset CCMR1
    TIM2->CCER  = 0x0000;  // Reset CCER

    // Mapear entradas a TI1/TI2
    TIM2->CCMR1 |= (1 << TIM_CCMR1_CC1S_Pos); // CC1 -> TI1
    TIM2->CCMR1 |= (1 << TIM_CCMR1_CC2S_Pos); // CC2 -> TI2

    // Polaridad normal
    TIM2->CCER &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);

    // Encoder mode x4
    TIM2->SMCR |= TIM_SMCR_SMS_0 | TIM_SMCR_SMS_1; // SMS = 011


    TIM2->ARR = 0xFFFF;   // Rango máximo del contador (16 bits)
    TIM2->CNT = 0x0000;   // Reset del contador

    /* 4. Encender el timer */
    TIM2->CR1 |= TIM_CR1_CEN;
}

/* Leer el contador */
int encoder_get_count(void) {
    return (int)(TIM2->CNT);  // firmar a 16 bits para permitir valores negativos
}


int main(void){
	encoderInit();
	// Inicializar reloj de puerto C
	RCC->AHBENR |= RCC_AHBENR_GPIOCEN;
	pwmInit();//Inicializar PWM
	adcInit();//Inicializar adc
	initIR();//Inicializar interrupción

	while(1){

		//Función a diferencias
		if(flag == 1){
			flag = 0;
			/*//Aproximación de función escalón
					if(t<4000){
						x_ref=0.5;//Valor de referencia

					}
					else if(t<8000){
						x_ref = 1.5;
					}
					else{
						t = 0;
					}*/
			encoder_counter = encoder_get_count();
			delta = encoder_counter - encoder_prev;    // diferencia de pulsos desde la última lectura
			encoder_prev = encoder_counter;            // guardar para próxima iteración
			x_vel=(delta / 2000.0) * (60.0 / 0.001);//Escalamos a la lectura de conversión del ADC (2^12) bits

			//x_refVel=80;//Cantidad de pulsos del encoder (250PPR)
			e = x_refVel - x_vel;//Algoritmo de control
			int_error=int_error+0.001*e;//Cálculo de integral
			der_error=(e-e_1)/0.001;//Cálculo de la derivada
			m=kp*e+ki*int_error+kd*der_error;
			//m=200;
			e_1=e;

			//Definir limites de señal de voltaje (amplitud)
			if(m>500){
				m=500;
			}
			else if(m<-500){
				m=-500;
			}
			else{
				if(m<0){
					m=m*-1;
					TIM3->CCR4 = m;
					TIM3->CCR3 = 0;
				}
				else{
					TIM3->CCR3 = m;
					TIM3->CCR4 = 0;
				}
			}



	}
}
}
//Handler de la interrupción
void TIM14_IRQHandler(void){
	TIM14->SR = 0; // Clear status register
	t = t + 1;
	flag = 1;
}



