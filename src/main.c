/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stm32f051x8.h>
#include <pwmInit.h>
#include <adcInit.h>
#include <readAdc.h>
#include <initIR.h>



#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

int t = 0;
int flag = 0;
int analogRead3 = 0;

float X = 0, X_1 = 0, X_2 = 0; // Variables para posición
float F = 0, F_1 = 0, F_2 = 0; // Variables para fuerza

//Coeficientes con tiempo de simulación t=1ms
float a = 7.18266490806209e-05;
float b = 7.16544710587613e-05;
float c = -1.99268237678367;
float d = 0.992825857903813;

int main(void){
	// Inicializar reloj de puerto C
	RCC->AHBENR |= RCC_AHBENR_GPIOCEN;
	pwmInit();//Inicializar PWM
	adcInit();//Inicializar adc
	initIR();//Inicializar interrupción

	while(1){

		//Aproximación de función escalón
		/*if(t<2000){
			F = 0;
		}
		else if(t<10000){
			F = 1;
		}
		else{
			t = 0;
		}*/

		//Función a diferencias
		if(flag == 1){
			flag = 0;
			analogRead3=readAdc();//Leer adc
			F=3.3*analogRead3/4095;//Escalamos a la lectura de conversión del ADC (2^12) bits
			X = a*F_1 + b*F_2 - c*X_1 - d*X_2;//Ecuación a diferencias

			//Actualización de variables para el siguiente paso
			X_2 = X_1;
			X_1 = X;
			F_2 = F_1;
			F_1 = F;

			//Definir limites de señal de voltaje (amplitud)
			if(X>3.3){
				X=3.3;
			}
			else if(X<0){
				X=0;
			}

			//Escalar la variable a la frecuencia de pwm
			TIM3->CCR4 = 500*X/3.3;
		}

	}
}

//Handler de la interrupción
void TIM14_IRQHandler(void){
	TIM14->SR = 0; // Clear status register
	t = t + 1;
	flag = 1;
}
